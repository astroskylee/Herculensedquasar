#!/usr/bin/env python3
"""RXJ1131 modelling pipeline up to HMC, exported from RXJ1131_model.ipynb.

This script executes the notebook workflow through the HMC batch loop,
then concatenates all batches and saves the combined inference data.
"""

from pathlib import Path
import os
import matplotlib

# Ensure script runs reproducibly from its own directory and without GUI backend.
SCRIPT_DIR = Path(__file__).resolve().parent
os.chdir(SCRIPT_DIR)
matplotlib.use("Agg")

# User-requested output folder for HMC batches and concatenated result.
quasat_hmc_dir = SCRIPT_DIR / "quasat_hmc"
quasat_hmc_dir.mkdir(parents=True, exist_ok=True)


# -----------------------------
# Notebook Cell 0
# -----------------------------
import sys
import os
import warnings
warnings.simplefilter("ignore")
# parentdir = os.path.abspath('../..')
# sys.path.insert(0, parentdir) 
from herculens_import_main import *
import jax
import numpyro
jax.config.update('jax_enable_x64', True)
numpyro.enable_x64()

os.environ['XLA_PYTHON_CLIENT_PREALLOCATE'] = 'false'
os.environ['XLA_FLAGS'] = (
    '--xla_gpu_enable_triton_softmax_fusion=true '
    '--xla_gpu_triton_gemm_any=True '
    '--xla_gpu_enable_async_collectives=true '
    '--xla_gpu_enable_latency_hiding_scheduler=true '
    '--xla_gpu_enable_highest_priority_async_stream=true '
)
if 'graphviz' not in os.environ['PATH']:
    os.environ['PATH'] = '/opt/apps/pkgs/graphviz/12.2.1/intel64/gnu_12.2.0/bin:' + os.environ['PATH']

# -----------------------------
# Notebook Cell 1
# -----------------------------
pix_scale = 0.05  # arcsec / pixel (HST)

DATA_DIR = "../../Data/RXJ1131"
raw_data_path = os.path.join(DATA_DIR, "j8oi74010_drc.fits")
data_path = os.path.join(DATA_DIR, "j8oi74010_drc_cut_x2116_y3377_200_scierr_corner5.fits")
mask_path = os.path.join(DATA_DIR, "mask.fits")
# mask_out is set to all True by design (full image likelihood region)
with fits.open(raw_data_path, memmap=True) as hdul_raw:
    exposure_time = float(hdul_raw[0].header.get("EXPTIME", hdul_raw[0].header.get("TEXPTIME", 1.0)))

with fits.open(data_path, memmap=True) as hdul:
    data = jnp.array(hdul["SCI"].data) if "SCI" in hdul else jnp.array(hdul[0].data)
    rms_file = jnp.array(hdul["ERR"].data)

mask = jnp.array(fits.getdata(mask_path), dtype=bool)
mask_out = jnp.ones_like(data, dtype=bool)
# mask =  jnp.array(mask_out, dtype=bool)

valid = jnp.isfinite(data) & jnp.isfinite(rms_file) & (rms_file > 0)
mask = mask & valid
# keep mask_out fully True as requested
if mask.shape != data.shape or mask_out.shape != data.shape:
    raise ValueError(f"Mask shape mismatch: data={data.shape}, mask={mask.shape}, mask_out={mask_out.shape}")
npix = int(mask_out.sum())

corner_pixel = 10
bkg_corner = np.array(data[:corner_pixel, :corner_pixel])
bkg_mean = float(np.nanmean(bkg_corner))
bkg_rms = float(np.nanstd(bkg_corner))

data = data - bkg_mean
rms = float(np.nanmedian(np.array(rms_file[mask_out])))

# strict: use only model PSF generated by Step 3
psf_path_model = os.path.join("./psf_data", "PSF_model_step3_svi.fits")
if not os.path.exists(psf_path_model):
    raise FileNotFoundError(f"Required model PSF not found: {psf_path_model}")

with fits.open(psf_path_model, memmap=True) as hdul_psf:
    if "DET_PSF_MODEL" in hdul_psf:
        psf_hst = np.array(hdul_psf["DET_PSF_MODEL"].data, dtype=float)
    elif "DET_PSF_NORM" in hdul_psf:
        psf_hst = np.array(hdul_psf["DET_PSF_NORM"].data, dtype=float)
    elif len(hdul_psf) > 1 and hdul_psf[1].data is not None:
        psf_hst = np.array(hdul_psf[1].data, dtype=float)
    elif hdul_psf[0].data is not None:
        psf_hst = np.array(hdul_psf[0].data, dtype=float)
    else:
        raise ValueError("PSF model FITS missing usable image extension")

psf_hst = np.clip(psf_hst, 0, None)
psf_hst = psf_hst / np.sum(psf_hst)
psf_used = psf_path_model

if psf_hst.shape[0] != psf_hst.shape[1] or psf_hst.shape[0] % 2 == 0:
    raise ValueError(f"PSF kernel must be square odd-sized, got {psf_hst.shape}")

print(f"Using PSF model: {psf_used}")
psf = PSF(psf_type='PIXEL', kernel_point_source=psf_hst)

pixel_grid, xgrid, ygrid, x_axis, y_axis, extent, nx, ny = get_pixel_grid(data, pix_scale)
noise = Noise(nx, ny, exposure_time=exposure_time)
provided_rms = True

N_gauss_light = 8
N_gauss_source = 1

sigma_lims_lens = [0.01, 3.0]
sigma_lims = [0.01, 0.5]

lens_light_ps_pos = jnp.array([0.5, -0.1])

source_grid_scale = 0.7

conj_points = jnp.array([
    [0.26298137209467, 2.09255496979808],
    [1.35258643634931, 1.62712406079166],
    [-1.00020401055449, 2.01497731965513],
    [-0.22609309020619, -1.10668714778579],
])

ss_factor = 2

PSF_CORNER_SIZE = 5

def compute_psf_corner_median(psf_kernel, corner_size=PSF_CORNER_SIZE):
    ny, nx = psf_kernel.shape
    cs = min(corner_size, ny, nx)
    corners = np.concatenate([
        psf_kernel[:cs, :cs].reshape(-1),
        psf_kernel[:cs, -cs:].reshape(-1),
        psf_kernel[-cs:, :cs].reshape(-1),
        psf_kernel[-cs:, -cs:].reshape(-1),
    ])
    return float(np.nanmedian(corners))

psf_corner_median = compute_psf_corner_median(psf_hst, corner_size=PSF_CORNER_SIZE)
print(f"PSF corner median ({PSF_CORNER_SIZE}x{PSF_CORNER_SIZE}) = {psf_corner_median:.3e}")

def subtract_psf_corner_median(model_image, psf_median=psf_corner_median):
    return model_image - jnp.asarray(psf_median, dtype=model_image.dtype)

# -----------------------------
# Notebook Cell 2
# -----------------------------
plt.imshow(psf_hst, norm = 'log')

# -----------------------------
# Notebook Cell 3
# -----------------------------
plt.imshow(data, origin='lower', cmap='twilight', extent=extent, norm="log")
plt.colorbar();
plt.contour(mask, levels=[0.5], colors='#ff3300', alpha = 0.95, linewidth = 2, linestyles='dashed', origin='lower', extent=extent)
plt.contour(mask_out, levels=[0.5], colors='#9933ff', alpha = 0.95, linestyles='dashed', origin='lower', extent=extent)
plt.plot(conj_points[:, 0], conj_points[:, 1], 'o', alpha = 0.5, markersize = 1, color='red')

# -----------------------------
# Notebook Cell 4
# -----------------------------
from herculens.PointSourceModel.point_source_model import PointSourceModel

mass_model = MassModel(['EPL', 'SHEAR'])

lens_light_model = LightModel(['MULTI_GAUSSIAN_ELLIPSE'],{})

source_light_model = LightModel(['MULTI_GAUSSIAN_ELLIPSE'],{})

point_source_model = PointSourceModel(
    ['IMAGE_POSITIONS'],
    mass_model=mass_model,
    image_plane=pixel_grid,
)

lens_image = LensImageExtension(
    pixel_grid,
    psf,
    noise_class=noise,
    lens_light_model_class=lens_light_model,
    lens_mass_model_class=mass_model,
    source_model_class=source_light_model,
    point_source_model_class=point_source_model,
    source_arc_mask=mask,
    conjugate_points=conj_points,
    kwargs_numerics={'supersampling_factor': ss_factor},
    source_grid_scale = source_grid_scale
)

# -----------------------------
# Notebook Cell 5
# -----------------------------
npix = int(mask_out.sum())
def model(data, conj = True, provided_rms = False):
    mass_params = EPL_w_shear('Mass model', '1', gamma_low = 1.95, gamma_up = 2.05, center_high = 0.5, center_low = -0.5,)
    lens_light = multi_gauss_light('Lens light', 'lens', N_gauss_light, sigma_lims = sigma_lims_lens,e_high = 0.2, e_low = -0.2)

    n_ps = conj_points.shape[0]
    ra_ps = numpyro.sample(
        'ra_ps',
        dist.TruncatedNormal(
            loc=conj_points[:, 0],
            scale=0.05,
            low=conj_points[:, 0] - 0.2,
            high=conj_points[:, 0] + 0.2,
        ),
    )
    dec_ps = numpyro.sample(
        'dec_ps',
        dist.TruncatedNormal(
            loc=conj_points[:, 1],
            scale=0.05,
            low=conj_points[:, 1] - 0.2,
            high=conj_points[:, 1] + 0.2,
        ),
    )
    log10_amp_ps = numpyro.sample(
        'log10_amp_ps',
        dist.Uniform(-3.0, 4.5).expand([n_ps]),
    )
    log10_amp_lens_ps = numpyro.sample(
        'log10_amp_lens_ps',
        dist.Uniform(-3.0, 4.5),
    )
    amp_quasar_ps = jnp.power(10.0, log10_amp_ps)
    amp_lens_ps = jnp.power(10.0, log10_amp_lens_ps)
    kwargs_point_source = [{
        'ra': jnp.concatenate([ra_ps, jnp.array([lens_light_ps_pos[0]])]),
        'dec': jnp.concatenate([dec_ps, jnp.array([lens_light_ps_pos[1]])]),
        'amp': jnp.concatenate([amp_quasar_ps, jnp.array([amp_lens_ps])]),
    }]

    conj_points_model = lens_image.trace_conjugate_points(mass_params)
    source_center = jnp.mean(conj_points_model, axis=0)
    source_light = multi_gauss_light_center(
        'Source light',
        'source',
        N_gauss_source,
        sigma_lims,
        center_det=source_center,
    )
    conj_distance = reduced_distance_matrix(conj_points_model)
    nc = conj_distance.shape[0]
    if conj:
        with numpyro.plate(f'Conjugate points 2 - [{nc}]', nc):
            numpyro.sample('conjugate_points', dist.Exponential(1000), obs=conj_distance)

    model_image = lens_image.model(
        kwargs_lens=mass_params,
        kwargs_source=source_light,
        kwargs_lens_light=lens_light,
        kwargs_point_source=kwargs_point_source,
        source_add=True,
        point_source_add=True,
    )

    if provided_rms:
        model_std = rms_file
    else:
        background_rms_model = numpyro.sample('RMS', dist.LogUniform(rms * 0.5, rms * 1.5))
        #lens_image.Noise._background_rms = background_rms_model
        model_var = lens_image.Noise.C_D_model(model_image, background_rms = background_rms_model)
        model_std = jnp.sqrt(model_var)

    model_image_masked_out = model_image[mask_out]
    model_std_masked_out = model_std[mask_out]

    with numpyro.plate(f'Data masked - [{npix}]', npix):
        numpyro.sample('obs', dist.Normal(model_image_masked_out, model_std_masked_out), obs=data[mask_out])


def params2kwargs(params, fixed_params={}):
    params_full = params | fixed_params
    kwargs_lens = params2kwargs_EPL_w_shear(params_full, '1')
    kwargs_lens_light = params2kwargs_multi_gauss_light(params_full, 'lens')
    if 'center_source' not in params_full:
        conj_points_model = lens_image.trace_conjugate_points(kwargs_lens)
        source_center = jnp.mean(conj_points_model, axis=0)
        n_source = params_full['amp_source'].shape[0]
        center_source = jnp.vstack([
            jnp.full((n_source,), source_center[0]),
            jnp.full((n_source,), source_center[1]),
        ])
        params_full = params_full | {'center_source': center_source}
    kwargs_point_source = [{
        'ra': jnp.concatenate([params_full['ra_ps'], jnp.array([lens_light_ps_pos[0]])]),
        'dec': jnp.concatenate([params_full['dec_ps'], jnp.array([lens_light_ps_pos[1]])]),
        'amp': jnp.concatenate([
            jnp.power(10.0, params_full['log10_amp_ps']),
            jnp.array([jnp.power(10.0, params_full['log10_amp_lens_ps'])]),
        ]),
    }]
    return {
        'kwargs_lens': kwargs_lens,
        'kwargs_source': params2kwargs_multi_gauss_light(params_full, 'source'),
        'kwargs_lens_light': kwargs_lens_light,
        'kwargs_point_source': kwargs_point_source,
    }

model_graph = numpyro.render_model(model, model_args=(data,), render_distributions=True)

# -----------------------------
# Notebook Cell 6
# -----------------------------
max_iterations = 10000
num_chains = 4

init_fun = infer.init_to_median(num_samples=25)
guide = autoguide.AutoLowRankMultivariateNormal(model, init_loc_fn=init_fun)
scheduler = split_scheduler(max_iterations, init_value=0.01, transition_steps=[200, 10])
optim = optax.adabelief(learning_rate=scheduler)
loss = infer.Trace_ELBO (num_particles=1)

rng_key = jax.random.PRNGKey(42)
rng_key, rng_key_ = jax.random.split(rng_key)
svi_keys = jax.random.split(rng_key_, num_chains)
svi = SVI_vec(model, guide, optim, loss)
multi_svi_results = svi.run(rng_key, num_chains, max_iterations, data, provided_rms = provided_rms, stable_update = True)
multi_svi_median = guide.median(multi_svi_results.params)

multi_svi_median_herc = median_params2kwargs(params2kwargs, multi_svi_median, jnp.arange(num_chains))


_, ax = plt.subplots(figsize=(15, 3.5))
axins = ax.inset_axes([0.3, 0.5, 0.64, 0.45])

for losses in multi_svi_results.losses:
    _ = plot_loss(losses, max_iterations, ax=ax, axins=axins, alpha=0.25)

# -----------------------------
# Notebook Cell 7
# -----------------------------
from lens_images_extension import pixelize_plane as pixelize_plane_single
for i in range(4):
    plt.figure(figsize = (15,10))
    plt.subplot(2,3,1)
    plt.imshow(data, norm = 'log', cmap = 'twilight', extent = extent, origin = 'lower')
    plt.subplot(2,3,2)
    image_model = lens_image.model(**get_value_from_index(multi_svi_median_herc, i), source_add = True)
    plt.imshow(image_model, norm = 'log', cmap = 'twilight', extent = extent)
    plt.subplot(2,3,3)

    plt.imshow((data - image_model)/rms_file, cmap = 'bwr', vmax = 3, vmin = -3)
    plt.subplot(2,3,4)
    lens_light = lens_image.model(**get_value_from_index(multi_svi_median_herc, i), source_add = False)
    plt.imshow(data - lens_light, norm = 'log', cmap = 'twilight', extent = extent)

    plt.subplot(2,3,5)
    plt.imshow(image_model - lens_light, norm = 'log', cmap = 'twilight', extent = extent)
    plt.subplot(2,3,6)
    source, source_extent = pixelize_plane_single(
        lens_image,
        get_value_from_index(multi_svi_median_herc, i),
        100,
    )
    plt.imshow(source, extent = source_extent, norm = 'log', cmap = 'twilight')

# -----------------------------
# Notebook Cell 8
# -----------------------------
best_pix_sizes = np.array([
    get_best_pixel_size(
        lens_image,
        get_value_from_index(multi_svi_median_herc, i),
        source_grid_scale
    ) for i in range(num_chains)
])
pixel_grid_shape = np.median(best_pix_sizes).astype(int)*1
# pixel_grid_shape = 50
print(pixel_grid_shape)

# -----------------------------
# Notebook Cell 9
# -----------------------------
vars_mass = ['theta_E_1', 'gamma_1', 'e_1', 'center_1', 'gamma_sheer_1']
vars_lens_light = ['A_lens', 'sigma_lens', 'e_lens', 'center_lens']
vars_source_light = ['A_source', 'sigma_source', 'e_source']
vars_point_source = ['ra_ps', 'dec_ps', 'log10_amp_ps', 'log10_amp_lens_ps']
vars_other = []

svi_samples = guide.sample_posterior(rng_key_, multi_svi_results.params, sample_shape=(1000,))
svi_samples_chains = jax.tree.map(lambda x: jnp.swapaxes(x, 0, 1), svi_samples)
svi_samples_chains = jax.device_get(svi_samples_chains)
multi_svi_guide_sample = az.from_dict(svi_samples_chains)

k_grid = K_grid((pixel_grid_shape, pixel_grid_shape))

@jax.vmap
def get_image(idx):
    i, _ = pixelize_plane_single(lens_image, get_value_from_index(multi_svi_median_herc, idx), pixel_grid_shape, source_grid_scale=source_grid_scale)
    return i
orig_source = get_image(jnp.arange(num_chains))
ps_keys = jax.random.split(rng_key_, num_chains)
from herculens_import_main import source_power_spectrum
ps_fits = source_power_spectrum(orig_source, ps_keys, None, True)

keys_for_pixel_init = vars_lens_light + vars_mass + vars_point_source + vars_other
multi_svi_median_pixelated = {k: multi_svi_median[k] for k in keys_for_pixel_init if k in multi_svi_median} | ps_fits

# -----------------------------
# Notebook Cell 10
# -----------------------------
k_grid = K_grid((pixel_grid_shape, pixel_grid_shape))

from herculens.PointSourceModel.point_source_model import PointSourceModel

mass_model_pixel = MassModel(['EPL', 'SHEAR'])
lens_light_model_pixel = LightModel(['MULTI_GAUSSIAN_ELLIPSE'],{})

source_light_model_pixel = LightModel(
    ['PIXELATED',],
    pixel_adaptive_grid=True,
    pixel_interpol='fast_bilinear',
    kwargs_pixelated={'num_pixels': pixel_grid_shape}
)

pixel_grid_pixel = deepcopy(pixel_grid)
psf_pixel = deepcopy(psf)

point_source_model_pixel = PointSourceModel(
    ['IMAGE_POSITIONS'],
    mass_model=mass_model_pixel,
    image_plane=pixel_grid_pixel,
)

lens_image_pixel = LensImageExtension(
    pixel_grid_pixel,
    psf_pixel,
    noise_class=noise,
    lens_light_model_class=lens_light_model_pixel,
    lens_mass_model_class=mass_model_pixel,
    source_model_class=source_light_model_pixel,
    point_source_model_class=point_source_model_pixel,
    source_arc_mask=mask,
    conjugate_points=conj_points,
    kwargs_numerics={'supersampling_factor': ss_factor},
    source_grid_scale=source_grid_scale,
)

# -----------------------------
# Notebook Cell 11
# -----------------------------
npix = int(mask_out.sum())
N_HIGH_SOURCE_GRID = 1000
def model_pixel_full(data, k_values, conj=True, n_value = None):
    mass_params = EPL_w_shear('Mass model', '1')
    lens_light = multi_gauss_light('Lens light', 'lens', N_gauss_light, sigma_lims = sigma_lims_lens,e_high = 0.2, e_low = -0.2)


    n_ps = conj_points.shape[0]
    ra_ps = numpyro.sample(
        'ra_ps',
        dist.TruncatedNormal(
            loc=conj_points[:, 0],
            scale=0.05,
            low=conj_points[:, 0] - 0.2,
            high=conj_points[:, 0] + 0.2,
        ),
    )
    dec_ps = numpyro.sample(
        'dec_ps',
        dist.TruncatedNormal(
            loc=conj_points[:, 1],
            scale=0.05,
            low=conj_points[:, 1] - 0.2,
            high=conj_points[:, 1] + 0.2,
        ),
    )
    log10_amp_ps = numpyro.sample(
        'log10_amp_ps',
        dist.Uniform(-3.0, 4.5).expand([n_ps]),
    )
    log10_amp_lens_ps = numpyro.sample(
        'log10_amp_lens_ps',
        dist.Uniform(-3.0, 4.5),
    )
    amp_quasar_ps = jnp.power(10.0, log10_amp_ps)
    amp_lens_ps = jnp.power(10.0, log10_amp_lens_ps)
    kwargs_point_source = [{
        'ra': jnp.concatenate([ra_ps, jnp.array([lens_light_ps_pos[0]])]),
        'dec': jnp.concatenate([dec_ps, jnp.array([lens_light_ps_pos[1]])]),
        'amp': jnp.concatenate([amp_quasar_ps, jnp.array([amp_lens_ps])]),
    }]
    
    if conj:
        conj_points_model = lens_image_pixel.trace_conjugate_points(mass_params)
        conj_distance = reduced_distance_matrix(conj_points_model)
        nc = conj_distance.shape[0]
        with numpyro.plate(f'Conjugate points 2 - [{nc}]', nc):
            numpyro.sample('conjugate_points', dist.Exponential(100), obs=conj_distance)

    source_light = [
        matern_power_spectrum('Source grid', 'source_grid', k_values, n_high=N_HIGH_SOURCE_GRID, n_value = n_value, positive = True),
        #multi_gauss_light('Source light', 'source', 1, sigma_lims)[0]
    ]

    model_image = lens_image_pixel.model(
        kwargs_lens=mass_params,
        kwargs_source=source_light,
        kwargs_lens_light=lens_light,
        kwargs_point_source=kwargs_point_source,
        point_source_add=True,
    )
    # model_image = subtract_psf_corner_median(model_image_raw)
    # numpyro.deterministic('psf_corner_median', jnp.asarray(psf_corner_median, dtype=model_image.dtype))
    
    if provided_rms:
        model_std = rms_file
    else:
        background_rms_model = numpyro.sample('RMS', dist.LogUniform(rms * 0.5, rms * 1.5))
        #lens_image.Noise._background_rms = background_rms_model
        model_var = lens_image.Noise.C_D_model(model_image_raw, background_rms = background_rms_model)
        model_std = jnp.sqrt(model_var)
        
    model_image_masked_out = model_image[mask_out]
    model_std_masked_out = model_std[mask_out]

    numpyro.deterministic('model_image', model_image)

    with numpyro.plate(f'Data masked - [{npix}]', npix):
        numpyro.sample('obs', dist.Normal(model_image_masked_out, model_std_masked_out), obs=data[mask_out])


def params2kwargs_pixel(params, fixed_params={}):
    params_full = params | fixed_params
    kwargs_lens = params2kwargs_EPL_w_shear(params_full, '1')
    kwargs_source = [params2kwargs_power_spectrum(params_full, 'source_grid'),]
    kwargs_lens_light = params2kwargs_multi_gauss_light(params_full, 'lens')
    kwargs_point_source = [{
        'ra': jnp.concatenate([params_full['ra_ps'], jnp.array([lens_light_ps_pos[0]])]),
        'dec': jnp.concatenate([params_full['dec_ps'], jnp.array([lens_light_ps_pos[1]])]),
        'amp': jnp.concatenate([
            jnp.power(10.0, params_full['log10_amp_ps']),
            jnp.array([jnp.power(10.0, params_full['log10_amp_lens_ps'])]),
        ]),
    }]
    return {
        'kwargs_lens': kwargs_lens,
        'kwargs_source': kwargs_source,
        'kwargs_lens_light': kwargs_lens_light,
        'kwargs_point_source': kwargs_point_source,
    }

model_graph = numpyro.render_model(
    model_pixel_full,
    model_args=(data, k_grid.k),
    model_kwargs={'conj': False},
    render_distributions=True
)
#model_graph.unflatten(stagger=2)

# -----------------------------
# Notebook Cell 12
# -----------------------------
import time
import threading

def periodic_printer(interval, stop_event):
    while not stop_event.is_set():
        time.sleep(interval)
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] running")
        
stop_event = threading.Event()
printer_thread = threading.Thread(target=periodic_printer, args=(120, stop_event), daemon=True)
printer_thread.start()
start = time.time()
###############################################################################################################################
max_iterations = 50000
num_chains = 4

init_fun = init_to_value_or_defer(values=get_value_from_index(multi_svi_median_pixelated, 1))
guide_pixel = autoguide.AutoDiagonalNormal(model_pixel_full,init_loc_fn=init_fun,init_scale=0.01)

scheduler = split_scheduler(max_iterations,init_value=0.01,transition_steps=[200, 10])
optim = optax.adabelief(learning_rate=scheduler)
loss = infer.TraceMeanField_ELBO()

@jax.vmap
def map_svi_pixel(key, i):
    init_fun = init_to_value_or_defer(values=get_value_from_index(multi_svi_median_pixelated, i))
    guide_pixel.init_loc_fn = init_fun
    svi_pixel = infer.SVI(model_pixel_full,guide_pixel,optim,loss)
    return svi_pixel.run(key, max_iterations, data, k_grid.k, conj=True, n_value = None,  progress_bar=False, stable_update=True)

svi_keys = jax.random.split(rng_key_, num_chains)
multi_svi_pixel_results = map_svi_pixel(svi_keys, jnp.arange(num_chains))
multi_svi_pixel_median = guide_pixel.median(multi_svi_pixel_results.params)
multi_svi_pixel_median_herc = median_params2kwargs(params2kwargs_pixel,multi_svi_pixel_median,jnp.arange(num_chains))

stop_event.set()
printer_thread.join()
end = time.time()
print(f"SVI runs for {end - start:.3f} s which is {(end - start)/60:.1f} min")


_, ax = plt.subplots(figsize=(15, 3.5))
axins = ax.inset_axes([0.3, 0.5, 0.64, 0.45])

for losses in multi_svi_pixel_results.losses:
    _ = plot_loss(losses, max_iterations, ax=ax, axins=axins, alpha=0.25)

#383 source pixels: 6120s

# -----------------------------
# Notebook Cell 13
# -----------------------------
from lens_images_extension import pixelize_plane as pixelize_plane_single
for i in range(4):
    plt.figure(figsize = (15,10))
    plt.subplot(2,3,1)
    plt.imshow(data, norm = 'log', cmap = 'twilight', extent = extent, origin = 'lower')
    plt.subplot(2,3,2)
    image_model = lens_image_pixel.model(**get_value_from_index(multi_svi_pixel_median_herc, i), source_add = True)
    # image_model = subtract_psf_corner_median(image_model_raw)
    plt.imshow(image_model, norm = 'log', cmap = 'twilight', extent = extent)
    plt.subplot(2,3,3)
    plt.imshow((data - image_model)/rms_file, cmap = 'bwr', vmax = 3, vmin = -3, extent=extent)
    plt.contour(mask, levels=[0.5], colors='black', alpha = 0.95, linewidth = 2, linestyles='dashed', origin='lower', extent=extent)
    plt.subplot(2,3,4)
    lens_light = lens_image_pixel.model(**get_value_from_index(multi_svi_pixel_median_herc, i), source_add = False)
    plt.imshow(data - lens_light, norm = 'log', cmap = 'twilight', extent = extent)

    plt.subplot(2,3,5)
    plt.imshow(image_model - lens_light, norm = 'log', cmap = 'twilight', extent = extent)
    plt.subplot(2,3,6)
    source, source_extent = pixelize_plane_single(
        lens_image_pixel,
        get_value_from_index(multi_svi_pixel_median_herc, i),
        pixel_grid_shape,
    )
    plt.imshow(source, extent = source_extent, norm = 'log', cmap = 'twilight')

# -----------------------------
# Notebook Cell 14
# -----------------------------
plt.imshow(source, extent = source_extent, cmap = 'twilight')

# -----------------------------
# Notebook Cell 16
# -----------------------------
vars_power = ['n_source_grid', 'rho_source_grid', 'sigma_source_grid']
vars_power = ['rho_source_grid', 'sigma_source_grid']

svi_samples_pixel = guide_pixel.sample_posterior(rng_key_, multi_svi_pixel_results.params, sample_shape=(1000,))
svi_samples_pixel_chains = jax.tree.map(lambda x: jnp.swapaxes(x, 0, 1), svi_samples_pixel)
svi_samples_pixel_chains = jax.device_get(svi_samples_pixel_chains)
multi_svi_guide_sample_pixel = az.from_dict(svi_samples_pixel_chains)

# -----------------------------
# Notebook Cell 17
# -----------------------------
vars_lens_mass = ['theta_E_1', 'gamma_1', 'e_1', 'center_1', 'gamma_sheer_1']
fig_corner = None
for i in range(num_chains):
    if i != 5:
        fig_corner = corner(
            multi_svi_guide_sample_pixel.isel(chain=i),
            var_names=vars_lens_mass,
            color=f'C{i}',
            fig=fig_corner,
            # hist_kwargs={'density': True}
        )

# plt.savefig('./result/pixel_svi_posterior.png')

# -----------------------------
# Notebook Cell 18
# -----------------------------
# best_i = int(multi_svi_pixel_results.losses[:, -1000:].mean(axis=1).argmin())

# # lens_light = params2kwargs_gauss_light(get_value_from_index(multi_svi_pixel_median, best_i), 'lens', N_gauss_light, sigma_lims_lens)
# # import pickle

# # with open('lens_light_slice.pkl', 'wb') as f:
# #     pickle.dump(lens_light, f)

# # vars_fixed = vars_lens_light 
# # svi_pixel_median = get_value_from_index(multi_svi_pixel_median, best_i)
# # fixed_params_pixel = {k:svi_pixel_median[k] for k in vars_fixed}
# # model_pixel_hmc_new = condition(model_pixel_full, fixed_params_pixel)

# -----------------------------
# Notebook Cell 20
# -----------------------------
vars_pixel = ['pixels_wn_source_grid']
vars_power = ['n_source_grid', 'rho_source_grid', 'sigma_source_grid']
vars_psf = ['ra_ps', 'dec_ps', 'log10_amp_ps', 'log10_amp_lens_ps']
multi_svi_pixel_median_vars = {k: multi_svi_pixel_median[k] for k in vars_mass + vars_power + vars_pixel + vars_other+vars_lens_light+vars_psf}# + 
unconstrined_svi_pixel_median = jax.vmap(lambda p: infer.util.unconstrain_fn(model_pixel_full, (data, k_grid.k), {}, p))(multi_svi_pixel_median_vars)
#unconstrined_svi_pixel_median_trim = get_value_from_indexs(unconstrined_svi_pixel_median, jnp.array([2, 5, 8, 4]))

unconstrined_svi_pixel_median = {k: v.astype(jnp.float64) for k, v in unconstrined_svi_pixel_median.items()}
rng_key, rng_key_ = jax.random.split(rng_key)

# -----------------------------
# Notebook Cell 21
# -----------------------------
from numpyro.infer import NUTS, MCMC
from custom_gibbs import MultiHMCGibbs

init_fun_pixel = init_to_value_or_defer(values=get_value_from_index(multi_svi_pixel_median, 0))

inner_kernels = [
    NUTS(
        model_pixel_full,
        init_strategy=init_fun_pixel,
        target_accept_prob=0.8,
        max_tree_depth=10,
        dense_mass=[('n_source_grid', 'rho_source_grid', 'sigma_source_grid'), ('A_lens', 'sigma_lens', 'e_lens', 'center_lens'), ('ra_ps', 'dec_ps', 'log10_amp_ps', 'log10_amp_lens_ps')],
    ),
    NUTS(
        model_pixel_full,
        init_strategy=init_fun_pixel,
        target_accept_prob=0.8,
        max_tree_depth=10,
        dense_mass=[('center_1',), ('theta_E_1',), ('e_1', 'gamma_1', 'gamma_sheer_1')],
    ),
]

outer_kernel = MultiHMCGibbs(
    inner_kernels,
    gibbs_sites_list=[vars_pixel+vars_power+vars_lens_light + vars_other + vars_psf, vars_mass]
)

mcmc_pixel = MCMC(
    outer_kernel,
    num_warmup=100,
    num_samples=100,
    num_chains=num_chains,
    progress_bar=True,
    chain_method='vectorized'
)

batch_number = 8
last_states = []
batch_list = []
for i in range(batch_number):
    if i == 0:
        mcmc_pixel.run(
            rng_key_,
            data,
            k_grid.k,
            conj=False,
            init_params=unconstrined_svi_pixel_median
        )
        last_states.append(jax.device_get(mcmc_pixel.last_state))
    else:
        mcmc_pixel.post_warmup_state = mcmc_pixel.last_state
        mcmc_pixel.run(
            mcmc_pixel.post_warmup_state.rng_key,
            data,
            k_grid.k,
            conj=False
        )
        last_states.append(jax.device_get(mcmc_pixel.last_state))

    mcmc_pixel._states = jax.device_get(mcmc_pixel._states)
    mcmc_pixel._states_flat = jax.device_get(mcmc_pixel._states_flat)
    mcmc_chain = az.from_numpyro(mcmc_pixel)
    mcmc_chain.to_netcdf(str(quasat_hmc_dir / f"RXJ1131{i}.nc"))
    batch_list.append(mcmc_chain)


# -----------------------------
# Concatenate HMC batches and save
# -----------------------------
inf_data = az.concat(*batch_list, dim="draw")
inf_data_path = quasat_hmc_dir / "RXJ1131_inf_data_concat.nc"
inf_data.to_netcdf(str(inf_data_path))
print(f"Saved concatenated inf_data to: {inf_data_path}")
